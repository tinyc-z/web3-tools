<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰¹é‡è½¬è´¦å·¥å…· - BNB</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .wallet-section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9ff;
            border-radius: 15px;
            border: 2px solid #e1e8ff;
        }

        .wallet-info {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 10px;
            border-left: 4px solid #4caf50;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e8ff;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(244, 67, 54, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .progress-section {
            margin-top: 30px;
            padding: 25px;
            background: #f8f9ff;
            border-radius: 15px;
            border: 2px solid #e1e8ff;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e1e8ff;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .log-section {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-entry.error {
            color: #ff6b6b;
        }

        .log-entry.success {
            color: #51cf66;
        }

        .log-entry.warning {
            color: #ffd43b;
        }

        .network-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #e1e8ff;
        }

        .info-card h4 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-card p {
            font-weight: 600;
            color: #333;
            word-break: break-all;
        }

        .transfer-type-tabs {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #e0e0e0;
        }

        .tab-button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: #f5f5f5;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #e0e0e0;
        }

        .transfer-params {
            animation: fadeIn 0.3s ease;
        }

        .token-symbol {
            color: #667eea;
            font-weight: bold;
            margin-left: 5px;
        }

        .balance-display {
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            color: #333;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .network-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ æ‰¹é‡è½¬è´¦å·¥å…·</h1>
            <p>åŸºäºæ™ºèƒ½åˆçº¦çš„é«˜æ•ˆ BSC æ‰¹é‡è½¬è´¦è§£å†³æ–¹æ¡ˆ</p>
        </div>

        <div class="content">
            <!-- é’±åŒ…è¿æ¥åŒºåŸŸ -->
            <div class="wallet-section">
                <button id="connectWallet" class="btn btn-primary">ğŸ¦Š è¿æ¥ OKX é’±åŒ…</button>
                

                
                <div id="walletInfo" class="wallet-info">
                    <div class="network-info">
                        <div class="info-card">
                            <h4>é’±åŒ…åœ°å€</h4>
                            <p id="walletAddress">æœªè¿æ¥</p>
                        </div>
                        <div class="info-card">
                            <h4>ç½‘ç»œ</h4>
                            <p id="networkName">æœªè¿æ¥</p>
                        </div>
                        <div class="info-card">
                            <h4>BNB ä½™é¢</h4>
                            <p id="bnbBalance">0 BNB</p>
                        </div>
                        <div class="info-card" id="tokenBalanceCard" style="display: none;">
                            <h4>ä»£å¸ä½™é¢</h4>
                            <p id="tokenBalance">--</p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- è½¬è´¦å‚æ•°è®¾ç½® -->
            <form id="transferForm">
                <!-- è½¬è´¦ç±»å‹é€‰æ‹© -->
                <div class="form-group">
                    <label>è½¬è´¦ç±»å‹:</label>
                    <div class="transfer-type-tabs">
                        <button type="button" class="tab-button active" data-type="bnb">BNB è½¬è´¦</button>
                        <button type="button" class="tab-button" data-type="erc20">ERC20 ä»£å¸è½¬è´¦</button>
                    </div>
                </div>

                <!-- BNB è½¬è´¦å‚æ•° -->
                <div id="bnbParams" class="transfer-params">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="minAmount">æœ€å°è½¬è´¦é‡‘é¢ (BNB)</label>
                            <input type="number" id="minAmount" step="0.001" value="0.001" required>
                        </div>
                        <div class="form-group">
                            <label for="maxAmount">æœ€å¤§è½¬è´¦é‡‘é¢ (BNB)</label>
                            <input type="number" id="maxAmount" step="0.001" value="0.001" required>
                        </div>
                    </div>
                </div>

                <!-- ERC20 è½¬è´¦å‚æ•° -->
                <div id="erc20Params" class="transfer-params" style="display: none;">
                    <div class="form-group">
                        <label for="tokenSelect">é€‰æ‹©ä»£å¸:</label>
                        <select id="tokenSelect">
                            <option value="">-- é€‰æ‹©é¢„é…ç½®ä»£å¸ --</option>
                            <option value="USDT">USDT</option>
                            <option value="USDF">USDF</option>
                            <option value="USD1">USD1</option>
                            <option value="ASTER">ASTER</option>
                            <option value="custom">è‡ªå®šä¹‰ä»£å¸åœ°å€</option>
                        </select>
                    </div>
                    <div class="form-group" id="customTokenGroup" style="display: none;">
                        <label for="customTokenAddress">è‡ªå®šä¹‰ä»£å¸åœ°å€:</label>
                        <input type="text" id="customTokenAddress" placeholder="0x..." pattern="^0x[a-fA-F0-9]{40}$">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="tokenMinAmount">æœ€å°é‡‘é¢:</label>
                            <input type="number" id="tokenMinAmount" step="0.000001" min="0" value="1" placeholder="1">
                            <span id="tokenSymbol" class="token-symbol"></span>
                        </div>
                        <div class="form-group">
                            <label for="tokenMaxAmount">æœ€å¤§é‡‘é¢:</label>
                            <input type="number" id="tokenMaxAmount" step="0.000001" min="0" value="1" placeholder="1">
                            <span id="tokenSymbol2" class="token-symbol"></span>
                        </div>
                    </div>
                    <div class="form-group" id="tokenBalanceGroup" style="display: none;">
                        <label>ä»£å¸ä½™é¢:</label>
                        <div id="tokenBalanceDisplay" class="balance-display">--</div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="batchSize">æ¯æ‰¹å¤„ç†æ•°é‡</label>
                    <input type="number" id="batchSize" value="200" min="1" max="500" required>
                </div>

                <div class="form-group">
                    <label for="addresses">æ¥æ”¶åœ°å€ (æ¯è¡Œä¸€ä¸ªåœ°å€)</label>
                    <textarea id="addresses" placeholder="0x1234567890123456789012345678901234567890&#10;0xabcdefabcdefabcdefabcdefabcdefabcdefabcd&#10;..." required></textarea>
                </div>

                <div class="btn-group">
                    <button type="submit" id="startTransfer" class="btn btn-success">ğŸš€ å¼€å§‹è½¬è´¦</button>
                    <button type="button" id="stopTransfer" class="btn btn-danger" disabled>â¹ï¸ åœæ­¢è½¬è´¦</button>
                </div>
            </form>

            <!-- è¿›åº¦æ˜¾ç¤ºåŒºåŸŸ -->
            <div id="progressSection" class="progress-section">
                <div class="progress-text" id="progressText">å‡†å¤‡ä¸­...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="network-info">
                    <div class="info-card">
                        <h4>å·²å¤„ç†</h4>
                        <p id="processedCount">0</p>
                    </div>
                    <div class="info-card">
                        <h4>æ€»æ•°é‡</h4>
                        <p id="totalCount">0</p>
                    </div>
                    <div class="info-card">
                        <h4>æˆåŠŸç‡</h4>
                        <p id="successRate">0%</p>
                    </div>
                    <div class="info-card">
                        <h4>æ€»èŠ±è´¹</h4>
                        <p id="totalSpent">0 BNB</p>
                    </div>
                </div>
                <div id="logSection" class="log-section"></div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let provider = null;
        let signer = null;
        let contract = null;
        let isTransferring = false;
        let shouldStop = false;
        let currentTransferType = 'bnb'; // 'bnb' æˆ– 'erc20'
        let currentTokenInfo = null;

        // åˆçº¦é…ç½®
        const CONTRACT_ADDRESS = "0x1e9DEA0Fcde9d3C417D509187ef470B2739956bb";
        
        // ERC20 ä»£å¸é…ç½® (BSC ç½‘ç»œ)
        const TOKENS = {
            USDT: {
                address: "0x55d398326f99059fF775485246999027B3197955",
                symbol: "USDT",
                name: "Tether USD",
                decimals: 18
            },
            ASTER: {
                address: "0x000ae314e2a2172a039b26378814c252734f556a",
                symbol: "ASTER",
                name: "Aster Token",
                decimals: 18
            },
            USDF: {
                address: "0x5A110fC00474038f6c02E89C707D638602EA44B5",
                symbol: "USDF",
                name: "USDF Token",
                decimals: 18
            },
            USD1: {
                address: "0x8d0d000ee44948fc98c9b98a4fa4921476f08b0d",
                symbol: "USD1",
                name: "USD1 Token",
                decimals: 18
            },
        };

        // ERC20 ABI
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function name() view returns (string)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)"
        ];
        const CONTRACT_ABI = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {"internalType": "address[]", "name": "recipients", "type": "address[]"},
                    {"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"}
                ],
                "name": "batchTransfer",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "token", "type": "address"},
                    {"internalType": "address[]", "name": "recipients", "type": "address[]"},
                    {"internalType": "uint256[]", "name": "amounts", "type": "uint256[]"}
                ],
                "name": "batchTransferERC20",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address payable", "name": "to", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "emergencyWithdrawNative",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "token", "type": "address"},
                    {"internalType": "address", "name": "to", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "emergencyWithdrawToken",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {"internalType": "address", "name": "", "type": "address"}
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            }
        ];

        // ç½‘ç»œé…ç½®
        const NETWORKS = {
            56: {
                name: 'BSC Mainnet',
                symbol: 'BNB',
                rpcUrl: 'https://bsc-dataseed1.binance.org/',
                blockExplorerUrl: 'https://bscscan.com'
            }
        };

        // DOM å…ƒç´ 
        const connectWalletBtn = document.getElementById('connectWallet');
        const walletInfo = document.getElementById('walletInfo');
        const walletAddress = document.getElementById('walletAddress');
        const networkName = document.getElementById('networkName');
        const walletBalance = document.getElementById('walletBalance');
        const transferForm = document.getElementById('transferForm');
        const startTransferBtn = document.getElementById('startTransfer');
        const stopTransferBtn = document.getElementById('stopTransfer');
        const progressSection = document.getElementById('progressSection');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const logSection = document.getElementById('logSection');

        // æ—¥å¿—å‡½æ•°
        function addLog(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logSection.appendChild(logEntry);
            logSection.scrollTop = logSection.scrollHeight;
        }

        // è¿æ¥é’±åŒ…
        async function connectWallet() {
            try {
                // æ£€æµ‹å¤šç§é’±åŒ…æä¾›è€…
                let walletProvider = null;
                let walletName = '';

                // æ£€æµ‹ OKX é’±åŒ…çš„å¤šç§å¯èƒ½æ–¹å¼
                if (typeof window.okxwallet !== 'undefined') {
                    walletProvider = window.okxwallet;
                    walletName = 'OKX';
                } else if (typeof window.okex !== 'undefined' && window.okex.ethereum) {
                    walletProvider = window.okex.ethereum;
                    walletName = 'OKX';
                } else if (typeof window.ethereum !== 'undefined') {
                    // æ£€æŸ¥æ˜¯å¦ä¸º OKX é’±åŒ…
                    if (window.ethereum.isOkxWallet || window.ethereum.isOKExWallet) {
                        walletProvider = window.ethereum;
                        walletName = 'OKX';
                    } else {
                        // å°è¯•ä½¿ç”¨é€šç”¨çš„ ethereum æä¾›è€…
                        walletProvider = window.ethereum;
                        walletName = 'Web3';
                    }
                }

                if (!walletProvider) {
                    alert('æœªæ£€æµ‹åˆ°é’±åŒ…æ‰©å±•ï¼Œè¯·ç¡®ä¿å·²å®‰è£… OKX é’±åŒ…æˆ–å…¶ä»– Web3 é’±åŒ…');
                    return;
                }

                addLog(`æ£€æµ‹åˆ° ${walletName} é’±åŒ…`, 'info');

                // è¯·æ±‚è¿æ¥é’±åŒ…
                const accounts = await walletProvider.request({
                    method: 'eth_requestAccounts'
                });

                if (accounts.length === 0) {
                    throw new Error('æœªè·å–åˆ°é’±åŒ…è´¦æˆ·');
                }

                // åˆ›å»º provider å’Œ signer
                provider = new ethers.BrowserProvider(walletProvider);
                signer = await provider.getSigner();

                // è·å–ç½‘ç»œä¿¡æ¯
                const network = await provider.getNetwork();
                const chainId = Number(network.chainId);

                // æ£€æŸ¥æ˜¯å¦ä¸º BSC ç½‘ç»œ
                if (chainId !== 56) {
                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x38' }], // BSC Mainnet
                        });
                        // é‡æ–°è·å–ç½‘ç»œä¿¡æ¯
                        const newNetwork = await provider.getNetwork();
                        const newChainId = Number(newNetwork.chainId);
                        if (newChainId !== 56) {
                            throw new Error('è¯·åˆ‡æ¢åˆ° BSC ä¸»ç½‘');
                        }
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            // ç½‘ç»œä¸å­˜åœ¨ï¼Œå°è¯•æ·»åŠ  BSC ç½‘ç»œ
                            try {
                                await walletProvider.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0x38',
                                        chainName: 'BSC Mainnet',
                                        nativeCurrency: {
                                            name: 'BNB',
                                            symbol: 'BNB',
                                            decimals: 18
                                        },
                                        rpcUrls: ['https://bsc-dataseed1.binance.org/'],
                                        blockExplorerUrls: ['https://bscscan.com/']
                                    }]
                                });
                            } catch (addError) {
                                throw new Error('è¯·æ‰‹åŠ¨æ·»åŠ å¹¶åˆ‡æ¢åˆ° BSC ä¸»ç½‘');
                            }
                        } else {
                            throw new Error('è¯·æ‰‹åŠ¨åˆ‡æ¢åˆ° BSC ä¸»ç½‘');
                        }
                    }
                }

                // è·å–ä½™é¢
                const address = await signer.getAddress();
                const balance = await provider.getBalance(address);

                // åˆ›å»ºåˆçº¦å®ä¾‹
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                // æ›´æ–° UI
                document.getElementById('walletAddress').textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;
                document.getElementById('networkName').textContent = NETWORKS[chainId]?.name || `Chain ID: ${chainId}`;
                document.getElementById('bnbBalance').textContent = `${ethers.formatEther(balance)} BNB`;
                
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('connectWallet').textContent = `âœ… ${walletName} é’±åŒ…å·²è¿æ¥`;
                document.getElementById('connectWallet').disabled = true;

                // å¦‚æœå·²é€‰æ‹©ä»£å¸ï¼Œæ›´æ–°ä»£å¸ä½™é¢
                if (currentTokenInfo) {
                    await updateTokenBalance();
                    // å¯åŠ¨å®šæ—¶æ›´æ–°
                    startBalanceUpdates();
                }

                addLog(`${walletName} é’±åŒ…è¿æ¥æˆåŠŸ`, 'success');
                addLog(`åœ°å€: ${address}`, 'info');
                addLog(`ä½™é¢: ${ethers.formatEther(balance)} BNB`, 'info');

                // è®¾ç½®é’±åŒ…äº‹ä»¶ç›‘å¬
                if (walletProvider.on) {
                    walletProvider.on('accountsChanged', handleAccountsChanged);
                    walletProvider.on('chainChanged', handleChainChanged);
                }

            } catch (error) {
                console.error('è¿æ¥é’±åŒ…å¤±è´¥:', error);
                addLog(`è¿æ¥é’±åŒ…å¤±è´¥: ${error.message}`, 'error');
                alert(`è¿æ¥é’±åŒ…å¤±è´¥: ${error.message}`);
            }
        }

        // å¤„ç†è´¦æˆ·å˜åŒ–
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                // é’±åŒ…æ–­å¼€è¿æ¥
                document.getElementById('walletInfo').style.display = 'none';
                document.getElementById('connectWallet').textContent = 'ğŸ¦Š è¿æ¥é’±åŒ…';
                document.getElementById('connectWallet').disabled = false;
                provider = null;
                signer = null;
                contract = null;
                
                // åœæ­¢ä½™é¢æ›´æ–°
                stopBalanceUpdates();
                
                addLog('é’±åŒ…å·²æ–­å¼€è¿æ¥', 'warning');
            } else {
                // è´¦æˆ·åˆ‡æ¢ï¼Œé‡æ–°è¿æ¥
                addLog('æ£€æµ‹åˆ°è´¦æˆ·åˆ‡æ¢ï¼Œé‡æ–°è¿æ¥é’±åŒ…...', 'info');
                connectWallet();
            }
        }

        // å¤„ç†ç½‘ç»œå˜åŒ–
        function handleChainChanged(chainId) {
            // ç½‘ç»œåˆ‡æ¢ï¼Œé‡æ–°è¿æ¥
            addLog('æ£€æµ‹åˆ°ç½‘ç»œåˆ‡æ¢ï¼Œé‡æ–°è¿æ¥é’±åŒ…...', 'info');
            connectWallet();
        }

        // è§£æåœ°å€åˆ—è¡¨
        function parseAddresses(addressText) {
            return addressText
                .split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr && ethers.isAddress(addr));
        }

        // ç”Ÿæˆè½¬è´¦é‡‘é¢
        function generateAmount(minAmount, maxAmount) {
            if (minAmount === maxAmount) {
                return ethers.parseEther(minAmount.toString());
            } else {
                const randomValue = Math.random() * (maxAmount - minAmount) + minAmount;
                return ethers.parseEther(randomValue.toFixed(8));
            }
        }

        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        async function updateBalances() {
            if (!signer) return;
            
            try {
                const address = await signer.getAddress();
                const balance = await provider.getBalance(address);
                document.getElementById('bnbBalance').textContent = `${ethers.formatEther(balance)} BNB`;
            } catch (error) {
                console.error('è·å–BNBä½™é¢å¤±è´¥:', error);
                document.getElementById('bnbBalance').textContent = 'è·å–å¤±è´¥';
            }
        }

        // æ›´æ–°ä»£å¸ä½™é¢
        async function updateTokenBalance() {
            if (!signer || !currentTokenInfo) return;
            
            try {
                const address = await signer.getAddress();
                const tokenContract = new ethers.Contract(currentTokenInfo.address, ERC20_ABI, provider);
                const balance = await tokenContract.balanceOf(address);
                const formattedBalance = ethers.formatUnits(balance, currentTokenInfo.decimals);
                
                document.getElementById('tokenBalance').textContent = `${formattedBalance} ${currentTokenInfo.symbol}`;
            } catch (error) {
                console.error('è·å–ä»£å¸ä½™é¢å¤±è´¥:', error);
                document.getElementById('tokenBalance').textContent = 'è·å–å¤±è´¥';
            }
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(processed, total, successCount, totalSpent, tokenSymbol = 'BNB') {
            const percentage = total > 0 ? (processed / total) * 100 : 0;
            const successRate = processed > 0 ? (successCount / processed) * 100 : 0;

            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `å¤„ç†è¿›åº¦: ${processed}/${total} (${percentage.toFixed(1)}%)`;
            
            document.getElementById('processedCount').textContent = processed;
            document.getElementById('totalCount').textContent = total;
            document.getElementById('successRate').textContent = `${successRate.toFixed(1)}%`;
            
            // ä¿®å¤BigIntè½¬æ¢é—®é¢˜
            let spentFormatted;
            if (typeof totalSpent === 'bigint') {
                spentFormatted = tokenSymbol === 'BNB' ? 
                    ethers.formatEther(totalSpent) : 
                    ethers.formatUnits(totalSpent, currentTokenInfo?.decimals || 18);
            } else {
                spentFormatted = totalSpent.toString();
            }
            
            document.getElementById('totalSpent').textContent = `${spentFormatted} ${tokenSymbol}`;
        }

        // éšæœºå»¶è¿Ÿ
        function randomDelay(min = 3000, max = 5000) {
            const delay = Math.floor(Math.random() * (max - min + 1)) + min;
            return new Promise(resolve => setTimeout(resolve, delay));
        }

        // å¼€å§‹æ‰¹é‡è½¬è´¦
        async function startBatchTransfer() {
            if (!signer || !contract) {
                alert('è¯·å…ˆè¿æ¥é’±åŒ…');
                return;
            }

            try {
                // æ ¹æ®è½¬è´¦ç±»å‹æ‰§è¡Œä¸åŒé€»è¾‘
                if (currentTransferType === 'bnb') {
                    await startBNBTransfer();
                } else {
                    await startERC20Transfer();
                }

            } catch (error) {
                console.error('æ‰¹é‡è½¬è´¦å¤±è´¥:', error);
                addLog(`æ‰¹é‡è½¬è´¦å¤±è´¥: ${error.message}`, 'error');
                alert(`æ‰¹é‡è½¬è´¦å¤±è´¥: ${error.message}`);
            } finally {
                // é‡ç½®çŠ¶æ€
                isTransferring = false;
                shouldStop = false;
                document.getElementById('startTransfer').disabled = false;
                document.getElementById('stopTransfer').disabled = true;
            }
        }

        // BNB è½¬è´¦é€»è¾‘
        async function startBNBTransfer() {
            // è·å–è¡¨å•æ•°æ®
            const minAmount = parseFloat(document.getElementById('minAmount').value);
            const maxAmount = parseFloat(document.getElementById('maxAmount').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const addressText = document.getElementById('addresses').value;

            // éªŒè¯è¾“å…¥
            if (minAmount <= 0 || maxAmount <= 0 || minAmount > maxAmount) {
                throw new Error('è½¬è´¦é‡‘é¢è®¾ç½®æ— æ•ˆ');
            }

            if (batchSize <= 0 || batchSize > 500) {
                throw new Error('æ‰¹æ¬¡å¤§å°å¿…é¡»åœ¨ 1-500 ä¹‹é—´');
            }

            // è§£æåœ°å€
            const addresses = parseAddresses(addressText);
            if (addresses.length === 0) {
                throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æ¥æ”¶åœ°å€');
            }

            // è®¾ç½®çŠ¶æ€
            isTransferring = true;
            shouldStop = false;
            document.getElementById('startTransfer').disabled = true;
            document.getElementById('stopTransfer').disabled = false;
            document.getElementById('progressSection').style.display = 'block';

            addLog(`å¼€å§‹æ‰¹é‡è½¬è´¦ï¼Œå…± ${addresses.length} ä¸ªåœ°å€`, 'info');
            addLog(`è½¬è´¦é‡‘é¢èŒƒå›´: ${minAmount} - ${maxAmount} BNB`, 'info');
            addLog(`æ‰¹æ¬¡å¤§å°: ${batchSize}`, 'info');

            let totalProcessed = 0;
            let totalSuccess = 0;
            let totalSpent = 0n;

            // åˆ†æ‰¹å¤„ç†
            for (let i = 0; i < addresses.length && !shouldStop; i += batchSize) {
                const batch = addresses.slice(i, i + batchSize);
                const batchNumber = Math.floor(i / batchSize) + 1;
                const totalBatches = Math.ceil(addresses.length / batchSize);

                addLog(`å¤„ç†ç¬¬ ${batchNumber}/${totalBatches} æ‰¹ï¼Œå…± ${batch.length} ä¸ªåœ°å€`, 'info');

                // ç”Ÿæˆé‡‘é¢æ•°ç»„
                const amounts = batch.map(() => generateAmount(minAmount, maxAmount));
                const totalNeeded = amounts.reduce((sum, amount) => sum + amount, 0n);

                addLog(`ç¬¬ ${batchNumber} æ‰¹æ€»é‡‘é¢: ${ethers.formatEther(totalNeeded)} BNB`, 'info');

                try {
                    // è·å– gas ä¿¡æ¯
                    const feeData = await provider.getFeeData();
                    const gasPrice = feeData.gasPrice;

                    // ä¼°ç®— gas
                    const estimatedGas = await contract.batchTransfer.estimateGas(batch, amounts, {
                        value: totalNeeded
                    });
                    const gasLimit = estimatedGas * 120n / 100n; // å¢åŠ 20%ç¼“å†²

                    addLog(`é¢„ä¼° Gas: ${estimatedGas.toString()}, Gas Price: ${ethers.formatUnits(gasPrice, 'gwei')} Gwei`, 'info');

                    // å‘é€äº¤æ˜“
                    const tx = await contract.batchTransfer(batch, amounts, {
                        value: totalNeeded,
                        gasLimit: gasLimit,
                        gasPrice: gasPrice
                    });

                    addLog(`â³ ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“å·²å‘é€: ${tx.hash}`, 'info');

                    // ç­‰å¾…äº¤æ˜“ç¡®è®¤
                    const receipt = await tx.wait();

                    if (receipt.status === 1) {
                        addLog(`âœ… ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“æˆåŠŸ: https://bscscan.com/tx/${tx.hash}`, 'success');
                        totalSuccess += batch.length;
                        totalSpent += totalNeeded;
                    } else {
                        addLog(`âŒ ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“å¤±è´¥`, 'error');
                    }

                } catch (error) {
                    addLog(`âŒ ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“å¤±è´¥: ${error.message}`, 'error');
                }

                totalProcessed += batch.length;
                // æ›´æ–°è¿›åº¦æ˜¾ç¤º
                updateProgress(totalProcessed, addresses.length, totalSuccess, totalSpent, currentTransferType === 'bnb' ? 'BNB' : currentTokenInfo.symbol);

                // éšæœºå»¶è¿Ÿ
                if (i + batchSize < addresses.length && !shouldStop) {
                    addLog('ç­‰å¾…éšæœºå»¶è¿Ÿ...', 'info');
                    await randomDelay();
                }
            }

            if (shouldStop) {
                addLog('è½¬è´¦å·²è¢«ç”¨æˆ·åœæ­¢', 'warning');
            } else {
                addLog(`âœ… æ‰¹é‡è½¬è´¦å®Œæˆï¼æ€»å…±å¤„ç† ${totalProcessed} ä¸ªåœ°å€ï¼ŒæˆåŠŸ ${totalSuccess} ä¸ªï¼Œå…±èŠ±è´¹ ${ethers.formatEther(totalSpent)} BNB`, 'success');
                // è½¬è´¦å®Œæˆåæ›´æ–°ä½™é¢
                await onTransferComplete();
            }
        }

        // ERC20 è½¬è´¦é€»è¾‘
        async function startERC20Transfer() {
            // éªŒè¯ä»£å¸ä¿¡æ¯
            if (!currentTokenInfo) {
                throw new Error('è¯·å…ˆé€‰æ‹©ä»£å¸');
            }

            const minAmount = parseFloat(document.getElementById('tokenMinAmount').value);
            const maxAmount = parseFloat(document.getElementById('tokenMaxAmount').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const addressText = document.getElementById('addresses').value;

            // éªŒè¯è¾“å…¥
            if (minAmount <= 0 || maxAmount <= 0 || minAmount > maxAmount) {
                throw new Error('è½¬è´¦é‡‘é¢è®¾ç½®æ— æ•ˆ');
            }

            if (batchSize <= 0 || batchSize > 500) {
                throw new Error('æ‰¹æ¬¡å¤§å°å¿…é¡»åœ¨ 1-500 ä¹‹é—´');
            }

            // è§£æåœ°å€
            const addresses = parseAddresses(addressText);
            if (addresses.length === 0) {
                throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„æ¥æ”¶åœ°å€');
            }

            // è®¾ç½®çŠ¶æ€
            isTransferring = true;
            shouldStop = false;
            document.getElementById('startTransfer').disabled = true;
            document.getElementById('stopTransfer').disabled = false;
            document.getElementById('progressSection').style.display = 'block';

            addLog(`å¼€å§‹æ‰¹é‡è½¬è´¦ ${currentTokenInfo.symbol}ï¼Œå…± ${addresses.length} ä¸ªåœ°å€`, 'info');
            addLog(`è½¬è´¦é‡‘é¢èŒƒå›´: ${minAmount} - ${maxAmount} ${currentTokenInfo.symbol}`, 'info');
            addLog(`æ‰¹æ¬¡å¤§å°: ${batchSize}`, 'info');

            // æ£€æŸ¥æˆæƒ
            const userAddress = await signer.getAddress();
            const allowance = await currentTokenInfo.contract.allowance(userAddress, CONTRACT_ADDRESS);
            const totalNeeded = ethers.parseUnits((maxAmount * addresses.length).toString(), currentTokenInfo.decimals);

            addLog(`æ£€æŸ¥ä»£å¸æˆæƒ: å½“å‰æˆæƒ ${ethers.formatUnits(allowance, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}`, 'info');
            addLog(`éœ€è¦æˆæƒ: ${ethers.formatUnits(totalNeeded, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}`, 'info');

            if (allowance < totalNeeded) {
                addLog('æˆæƒé¢åº¦ä¸è¶³ï¼Œéœ€è¦æˆæƒä»£å¸ä½¿ç”¨æƒé™...', 'warning');
                try {
                    const tokenContract = new ethers.Contract(currentTokenInfo.address, ERC20_ABI, signer);
                    
                    // å…ˆæ£€æŸ¥å½“å‰ä½™é¢
                    const balance = await tokenContract.balanceOf(userAddress);
                    addLog(`å½“å‰ä»£å¸ä½™é¢: ${ethers.formatUnits(balance, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}`, 'info');
                    
                    if (balance < totalNeeded) {
                        throw new Error(`ä»£å¸ä½™é¢ä¸è¶³ï¼éœ€è¦ ${ethers.formatUnits(totalNeeded, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}ï¼Œå½“å‰åªæœ‰ ${ethers.formatUnits(balance, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}`);
                    }
                    
                    addLog('å‘é€æˆæƒäº¤æ˜“...', 'info');
                    const approveTx = await tokenContract.approve(CONTRACT_ADDRESS, ethers.MaxUint256);
                    addLog(`æˆæƒäº¤æ˜“å·²å‘é€: ${approveTx.hash}`, 'info');
                    addLog('ç­‰å¾…æˆæƒäº¤æ˜“ç¡®è®¤...', 'info');
                    await approveTx.wait();
                    addLog('âœ… æˆæƒæˆåŠŸ', 'success');
                } catch (error) {
                    throw new Error(`æˆæƒå¤±è´¥: ${error.message}`);
                }
            } else {
                addLog('âœ… æˆæƒé¢åº¦å……è¶³ï¼Œæ— éœ€é‡æ–°æˆæƒ', 'success');
            }

            let totalProcessed = 0;
            let totalSuccess = 0;
            let totalSpent = 0n;

            // åˆ†æ‰¹å¤„ç†
            for (let i = 0; i < addresses.length && !shouldStop; i += batchSize) {
                const batch = addresses.slice(i, i + batchSize);
                const batchNumber = Math.floor(i / batchSize) + 1;
                const totalBatches = Math.ceil(addresses.length / batchSize);

                addLog(`å¤„ç†ç¬¬ ${batchNumber}/${totalBatches} æ‰¹ï¼Œå…± ${batch.length} ä¸ªåœ°å€`, 'info');

                // ç”Ÿæˆé‡‘é¢æ•°ç»„
                const amounts = batch.map(() => {
                    const randomValue = Math.random() * (maxAmount - minAmount) + minAmount;
                    return ethers.parseUnits(randomValue.toFixed(Math.min(currentTokenInfo.decimals, 18)), currentTokenInfo.decimals);
                });
                const batchTotal = amounts.reduce((sum, amount) => sum + amount, 0n);

                addLog(`ç¬¬ ${batchNumber} æ‰¹æ€»é‡‘é¢: ${ethers.formatUnits(batchTotal, currentTokenInfo.decimals)} ${currentTokenInfo.symbol}`, 'info');

                try {
                    // è°ƒç”¨åˆçº¦çš„batchTransferERC20å‡½æ•°
                    addLog(`å‘é€ç¬¬ ${batchNumber} æ‰¹ERC20è½¬è´¦äº¤æ˜“...`, 'info');
                    
                    const tx = await contract.batchTransferERC20(
                        currentTokenInfo.address,
                        batch,
                        amounts,
                        {
                            gasLimit: 500000 + (batch.length * 50000) // åŠ¨æ€è®¡ç®—gasé™åˆ¶
                        }
                    );
                    
                    addLog(`äº¤æ˜“å·²å‘é€: ${tx.hash}`, 'info');
                    addLog('ç­‰å¾…äº¤æ˜“ç¡®è®¤...', 'info');
                    
                    const receipt = await tx.wait();
                    
                    if (receipt.status === 1) {
                        addLog(`âœ… ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“æˆåŠŸï¼ŒGasä½¿ç”¨: ${receipt.gasUsed.toString()}`, 'success');
                        totalSuccess += batch.length;
                        totalSpent += batchTotal;
                    } else {
                        addLog(`âŒ ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“å¤±è´¥`, 'error');
                    }

                } catch (error) {
                    addLog(`âŒ ç¬¬ ${batchNumber} æ‰¹äº¤æ˜“å¤±è´¥: ${error.message}`, 'error');
                    
                    // å¦‚æœæ˜¯gasä¼°ç®—å¤±è´¥ï¼Œå°è¯•é™ä½æ‰¹æ¬¡å¤§å°
                    if (error.message.includes('gas') || error.message.includes('Gas')) {
                        addLog('å»ºè®®å‡å°‘æ‰¹æ¬¡å¤§å°é‡è¯•', 'warning');
                    }
                }

                totalProcessed += batch.length;
                 updateProgress(totalProcessed, addresses.length, totalSuccess, totalSpent, currentTransferType === 'bnb' ? 'BNB' : currentTokenInfo.symbol);

                // éšæœºå»¶è¿Ÿ
                if (i + batchSize < addresses.length && !shouldStop) {
                    addLog('ç­‰å¾…éšæœºå»¶è¿Ÿ...', 'info');
                    await randomDelay();
                }
            }

            if (shouldStop) {
                addLog('è½¬è´¦å·²è¢«ç”¨æˆ·åœæ­¢', 'warning');
            } else {
                addLog(`ERC20æ‰¹é‡è½¬è´¦å®Œæˆï¼æ€»å…±å¤„ç† ${totalProcessed} ä¸ªåœ°å€ï¼ŒæˆåŠŸ ${totalSuccess} ä¸ª`, 'success');
                // è½¬è´¦å®Œæˆåæ›´æ–°ä½™é¢
                await onTransferComplete();
            }
        }

        // åœæ­¢è½¬è´¦
        function stopTransfer() {
            if (isTransferring) {
                shouldStop = true;
                addLog('æ­£åœ¨åœæ­¢è½¬è´¦...', 'warning');
                document.getElementById('stopTransfer').disabled = true;
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('connectWallet').addEventListener('click', connectWallet);
        document.getElementById('transferForm').addEventListener('submit', (e) => {
            e.preventDefault();
            startBatchTransfer();
        });
        document.getElementById('stopTransfer').addEventListener('click', stopTransfer);

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', async () => {
            // åˆå§‹åŒ–è½¬è´¦ç±»å‹åˆ‡æ¢
            initTransferTypeTabs();
            
            // åˆå§‹åŒ–ä»£å¸é€‰æ‹©
            initTokenSelection();
            
            // æ£€æŸ¥é’±åŒ…è¿æ¥çŠ¶æ€
            checkWalletConnection();
        });

        // æ£€æŸ¥é’±åŒ…è¿æ¥çŠ¶æ€
        async function checkWalletConnection() {
            // æ£€æµ‹å¤šç§é’±åŒ…æä¾›è€…
            let walletProvider = null;
            
            if (typeof window.okxwallet !== 'undefined') {
                walletProvider = window.okxwallet;
            } else if (typeof window.okex !== 'undefined' && window.okex.ethereum) {
                walletProvider = window.okex.ethereum;
            } else if (typeof window.ethereum !== 'undefined') {
                walletProvider = window.ethereum;
            }

            if (walletProvider) {
                try {
                    const accounts = await walletProvider.request({
                        method: 'eth_accounts'
                    });
                    if (accounts.length > 0) {
                        await connectWallet();
                    }
                } catch (error) {
                    console.log('è‡ªåŠ¨è¿æ¥é’±åŒ…å¤±è´¥:', error);
                }
            }
        }

        // åˆå§‹åŒ–è½¬è´¦ç±»å‹åˆ‡æ¢
        function initTransferTypeTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const bnbParams = document.getElementById('bnbParams');
            const erc20Params = document.getElementById('erc20Params');

            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const type = this.dataset.type;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    // åˆ‡æ¢å‚æ•°é¢æ¿
                    if (type === 'bnb') {
                        bnbParams.style.display = 'block';
                        erc20Params.style.display = 'none';
                        currentTransferType = 'bnb';
                    } else {
                        bnbParams.style.display = 'none';
                        erc20Params.style.display = 'block';
                        currentTransferType = 'erc20';
                    }
                    
                    // æ˜¾ç¤º/éšè—ä»£å¸ä½™é¢å¡ç‰‡
                    const tokenBalanceCard = document.getElementById('tokenBalanceCard');
                    if (currentTransferType === 'erc20' && currentTokenInfo) {
                        tokenBalanceCard.style.display = 'block';
                    } else {
                        tokenBalanceCard.style.display = 'none';
                    }
                });
            });
        }

        // åˆå§‹åŒ–ä»£å¸é€‰æ‹©
        function initTokenSelection() {
            const tokenSelect = document.getElementById('tokenSelect');
            const customTokenGroup = document.getElementById('customTokenGroup');
            const customTokenAddress = document.getElementById('customTokenAddress');

            tokenSelect.addEventListener('change', async function() {
                const selectedToken = this.value;
                
                if (selectedToken === 'custom') {
                    customTokenGroup.style.display = 'block';
                    currentTokenInfo = null;
                    updateTokenSymbols('');
                } else if (selectedToken === '') {
                    customTokenGroup.style.display = 'none';
                    currentTokenInfo = null;
                    updateTokenSymbols('');
                    hideTokenBalance();
                } else {
                    customTokenGroup.style.display = 'none';
                    await loadTokenInfo(TOKENS[selectedToken].address);
                }
            });

            customTokenAddress.addEventListener('blur', async function() {
                const address = this.value.trim();
                if (address && ethers.isAddress(address)) {
                    await loadTokenInfo(address);
                }
            });
        }

        // åŠ è½½ä»£å¸ä¿¡æ¯
        async function loadTokenInfo(tokenAddress) {
            if (!provider) {
                addLog('è¯·å…ˆè¿æ¥é’±åŒ…', 'warning');
                return;
            }

            try {
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                
                const [symbol, decimals, name] = await Promise.all([
                    tokenContract.symbol(),
                    tokenContract.decimals(),
                    tokenContract.name()
                ]);

                currentTokenInfo = {
                    address: tokenAddress,
                    symbol,
                    decimals: Number(decimals), // ç¡®ä¿decimalsæ˜¯æ•°å­—ç±»å‹
                    name,
                    contract: tokenContract
                };

                updateTokenSymbols(symbol);
                
                // æ˜¾ç¤ºä»£å¸ä½™é¢ç»„
                    document.getElementById('tokenBalanceGroup').style.display = 'block';
                    
                    // æ˜¾ç¤ºä»£å¸ä½™é¢å¡ç‰‡
                    document.getElementById('tokenBalanceCard').style.display = 'block';
                    
                    // æ›´æ–°ä»£å¸ä½™é¢æ˜¾ç¤º
                    if (signer) {
                        await updateTokenBalance();
                        // å¯åŠ¨å®šæ—¶æ›´æ–°
                        startBalanceUpdates();
                    }
                
                // æ˜¾ç¤ºä»£å¸ä½™é¢ç»„
                    document.getElementById('tokenBalanceGroup').style.display = 'block';
                    
                    // æ˜¾ç¤ºä»£å¸ä½™é¢å¡ç‰‡
                    document.getElementById('tokenBalanceCard').style.display = 'block';
                    
                    // æ›´æ–°ä»£å¸ä½™é¢æ˜¾ç¤º
                    if (signer) {
                        await updateTokenBalance();
                        // å¯åŠ¨å®šæ—¶æ›´æ–°
                        startBalanceUpdates();
                    }
                    
                    addLog(`ä»£å¸ä¿¡æ¯åŠ è½½æˆåŠŸ: ${name} (${symbol})`, 'success');
            } catch (error) {
                addLog(`åŠ è½½ä»£å¸ä¿¡æ¯å¤±è´¥: ${error.message}`, 'error');
                currentTokenInfo = null;
                updateTokenSymbols('');
                hideTokenBalance();
            }
        }

        // æ›´æ–°ä»£å¸ç¬¦å·æ˜¾ç¤º
        function updateTokenSymbols(symbol) {
            document.getElementById('tokenSymbol').textContent = symbol;
            document.getElementById('tokenSymbol2').textContent = symbol;
        }

        // æ›´æ–°ä»£å¸ä½™é¢
        async function updateTokenBalance() {
            if (!currentTokenInfo || !signer) {
                hideTokenBalance();
                return;
            }

            try {
                const address = await signer.getAddress();
                const balance = await currentTokenInfo.contract.balanceOf(address);
                const formattedBalance = ethers.formatUnits(balance, currentTokenInfo.decimals);
                
                document.getElementById('tokenBalance').textContent = `${formattedBalance} ${currentTokenInfo.symbol}`;
                document.getElementById('tokenBalanceDisplay').textContent = `${formattedBalance} ${currentTokenInfo.symbol}`;
                document.getElementById('tokenBalanceGroup').style.display = 'block';
                
                // æ·»åŠ åˆ·æ–°æ—¶é—´æ˜¾ç¤º
                const now = new Date().toLocaleTimeString();
                console.log(`ä»£å¸ä½™é¢å·²æ›´æ–° (${now}): ${formattedBalance} ${currentTokenInfo.symbol}`);
            } catch (error) {
                addLog(`è·å–ä»£å¸ä½™é¢å¤±è´¥: ${error.message}`, 'error');
                hideTokenBalance();
            }
        }

        // å®šæ—¶æ›´æ–°ä»£å¸ä½™é¢
        let balanceUpdateInterval = null;
        
        function startBalanceUpdates() {
            // æ¸…é™¤ç°æœ‰çš„å®šæ—¶å™¨
            if (balanceUpdateInterval) {
                clearInterval(balanceUpdateInterval);
            }
            
            // æ¯30ç§’æ›´æ–°ä¸€æ¬¡ä½™é¢
            balanceUpdateInterval = setInterval(async () => {
                if (currentTokenInfo && signer) {
                    await updateTokenBalance();
                }
            }, 30000);
        }
        
        function stopBalanceUpdates() {
            if (balanceUpdateInterval) {
                clearInterval(balanceUpdateInterval);
                balanceUpdateInterval = null;
            }
        }

        // åœ¨æ‰¹é‡è½¬è´¦å®Œæˆåæ›´æ–°ä½™é¢
        async function onTransferComplete() {
            // æ›´æ–°ä»£å¸ä½™é¢
            if (currentTokenInfo && signer) {
                await updateTokenBalance();
                addLog('ä»£å¸ä½™é¢å·²æ›´æ–°', 'info');
            }
        }

        // éšè—ä»£å¸ä½™é¢
        function hideTokenBalance() {
            document.getElementById('tokenBalanceGroup').style.display = 'none';
        }

        // ç›‘å¬è´¦æˆ·å˜åŒ– - ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œå› ä¸ºå·²åœ¨ connectWallet ä¸­å¤„ç†
    </script>
</body>
</html>